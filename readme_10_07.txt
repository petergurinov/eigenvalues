#### Гуринов Петр ####
#### Задача №7 ####
#### QR алгоритм в варианте "метода отражений" поиска собственных значений для матриц общего вида, приведение к почти треугольному виду унитарным подобием методом отражений. ####



	## Описание интерфейса ##
Синтаксис: lss [input_filename] [output_filename] [options]

Возможные ключи:
	-d		режим отладки [По умолчанию отключенно]
	-dd		более подробный вывод режима отладки [По умолчанию отключенно]
	-e		печатать ошибок [По умолчанию отключенно]
	-p		печатать матрицу [По умолчанию отключенно]
	-t		печатать время выполнения [По умолчанию отключенно]
	-prec=<num>	precision	[default - 1e-14] 
	-eps=<num>	'epsilon'	[default - 1e-10]
	-max_iter=<num>	limit number of iterations	[default - 0, i.e. not limit]
	-h, -?		print this and exit
По умолчанию входной файл называется 10_07_in.txt
По умолчанию выходной файл называется 10_07_out.txt

Описание ключей:
-d - 	Выводит диагностические сообщения в ходе решения для облегчения процесса отладки.
	 	Выводит сообщения о том, какое действие выполняется программой.
	 	Выводит подробно операции проделываемые с матрицей и ее элементами.
-dd - 	Выводит диагностические сообщения в ходе решения для облегчения процесса отладки.
	 	Выводит сообщения о том, какое действие выполняется программой.
	 	Выводит более подробно ход операций проделываемых с матрицами и векторами и элементами.
-e - Печатает информацию об ошибках, произошедших в ходе работы программы.
-p - Печатает исходную матрицу перед началом решения и в самом конце получившуюся еденичную матрицу.
-t - Печатает время решения задачи после завершения работы решателя.
-h, -? - Печатает информацию о параметрах командной строки, возвращает 6 и завершает работу программы.

Возможные вариации задания параметров:
[options]
[input_file_name] [output_file_name] [options]
[input_file_name] [options]
[input_file_name] [output_file_name]
[input_file_name]

Описание кодов возвращаемых функцией main:
	-1	В случае корректной работы но метод решения не применим к данной системе возвращается -1.
	0	В случае корректной работы и если решение построено возвращается 0.
	1	В случае корректной работы но решения системы не существует возвращается 1.
	2	В случае, неправильно заданных ключей запуска, программа завершает работу, печатает help и возвращается 2.
	3	В случае не возможности открыть входной файл возвращается 3.
	4	В случае не возможности открыть выходной файл возвращается 4.
	5	В случае если матрица заданна не корректно возвращается 5.
	6	В случае запуска программы с ключом -h или -? возвращается 6.



	## Описание алгоритма ##
1. Приводим матрицу в почти треугольному виду
2. Применяем QR алгоритм методом отражений
3. В алгоритме используем ичерпывания и сдвиги



	## Описание функций ##
во всех функциях аргумент "int n" это размерность передоваемой матрицы или вектора. Либо указывается отдельно.

int usage(FILE* fl)
	печать справки.

int evc_memsize_10_07(int n)
	возвращает количество необходимой дополнительной памяти
	n*n - для хранения матрицы Q
	n - для хранения вектора X
	n*n - для хранения матрицы R
	n*n - для хранения матрицы U

int sim_memsize_10_07(int n)
	возвращает количество необходимой дополнительной памяти
	n*n - для хранения матрицы T
	n - для хранения вектора X
	n*n - для хранения матрицы U

void print_matr(int n, double *A)
	печать матрицы вида N - кол-во строк/столбов; матрица А;

void print_vec(int n, double *B);
	печать вектора B в строчку

int main(int argc, char **argv)интерфейс
	парсит строку запуска(char **argv)
	открывает файлы на запись и чтение
	считывает данные
	выделяет память
	запускает решение
	записывает ответ в файл
	освобождает память и закрывает файлы

double norma_10_07(int n, double *a)
	подсчет нормы вектора а
	возвращает норму вектора

double norma_matr_10_07(int n, double *A);
	подсчет нормы матрицы а
	возвращает норму матрицы

double u_10_07(int i, int j, double *x)
	считает элементы матрицы U на основе вектора x
	возвращает элемент из матрицы U[i, j]

void multip_matr_10_07(int n, double *A, double *B, double *C)
	перемножение мартрицы A*B и записывает ответ в матрицу C

void precision_10_07(int n, double *A, double precision)
	избавление от погрешности
	проходит по всей матрице и зануляет все элементы которые меньше по модулю значения precision

void copy_matr_10_07(int n, double *A, double *B)
	Копирование матрицы из B в A

void transpose_matr_10_07(int n, double *A)
	Транспонирование матрицы A

void exhaustion_10_07(int n, double *A, double epsilon)
	исчерпывания, А - матрица для которой применяем метод

double shift_10_07(int n, double *A, int *l)
	сдвиги, матрица А для которой применяем метод
	l номер диагонального элемента, изначально = n-1, при изменении в функции изменяется и в функции
	возвращает элемент которой отнимаем, что бы потом сложить его c A_k+1 матрицей

int check_q_10_07(int n, double *Q, double eps)
	проверяет, ялвляется ли матрица Q едничной
	при это учитывается epsilon
	возвращает 1 - матрица еденичная; 0 - еще не еденичная

int chek_count_step_10_07(int y, int max_iterations)
	второе правило выхода из цикла подсчета собственных значений
	возвращает значение 1 если надо продолжать, и 0 если надо закончить итерации
	основываяст на y - количество сделанных итераций, max_iterations - возможное кол-во итераций



int sim_10_07(int n, double* A, double* tmp, double precision)
	приведение матрицы к почти треугольному виду методом отражений
		строим вектор x
		по нему сторим матрицу U
		умножаем U*A*U
		и так повторяем эти операции n-1 раз

int evc_10_07(int n, int max_iterations, double epsilon, double* A, double* E, double* tmp, double precision)
	поиск собственных значения матрицы QR алгоритмом методом отражений
		запускаем исчерпывания и сдвиги
		строим матрицы Q и R для A_k
		строим матрицу A_k+1 = R*Q
		выполняем операции пока !check_q_10_07

